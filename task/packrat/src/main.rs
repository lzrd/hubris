// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

//! packrat: a task for caching data.
//!
//! There are several cases where we want a task to always start with the same
//! data; e.g., once `net` has come online and chosen a MAC address, it should
//! always use that MAC address even if the `net` task restarts. Packrat solves
//! this problem by being a place where tasks can store data (in the MAC address
//! case, the sequencer task for the relevant board reads the VPD and populates
//! the MAC address in packrat) that can be read back by any task (e.g., `net`).
//!
//! It is critical that packrat itself never restart, as a restart would cause
//! packrat to lose all the data it should be remembering! We attempt to
//! accomplish this via simplicity:
//!
//! 1. All of packrat's functionality should be straightforward get/set
//!    operations in memory; it makes no hardware accesses. For data that
//!    packrat should have that comes from hardware access (e.g., VPD), some
//!    other task is responsible for accessing hardware and then sending data to
//!    packrat.
//! 2. packrat does no parsing of incoming or outgoing data, other than that
//!    generated by the idol server implementation. It should call no fallible
//!    functions.
//! 3. packrat never calls into any other task, as calling into a task gives the
//!    callee opportunity to fault the caller.

#![no_std]
#![no_main]

use core::convert::Infallible;
use gateway_ereport_messages as ereport_messages;
use idol_runtime::{
    ClientError, Leased, LenLimit, NotificationHandler, RequestError,
};
use minicbor::CborLen;
use ringbuf::{counted_ringbuf, ringbuf, ringbuf_entry};
use static_cell::ClaimOnceCell;
use task_packrat_api::{
    CacheGetError, CacheSetError, HostStartupOptions, MacAddressBlock,
    VpdIdentity,
};
use userlib::{RecvMessage, TaskId, UnwrapLite};
use zerocopy::IntoBytes;

#[cfg(feature = "gimlet")]
mod gimlet;

#[cfg(feature = "grapefruit")]
mod grapefruit;

#[cfg(feature = "cosmo")]
mod cosmo;

mod spd_data;

#[cfg(feature = "gimlet")]
use gimlet::SpdData;

#[cfg(feature = "cosmo")]
use cosmo::SpdData;

#[cfg(not(any(feature = "gimlet", feature = "cosmo")))]
type SpdData = spd_data::SpdData<0, 0>; // dummy type

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[allow(dead_code)] // not all variants are used, depending on cargo features
enum Trace {
    None,
    MacAddressBlockSet(TraceSet<MacAddressBlock>),
    VpdIdentitySet(TraceSet<VpdIdentity>),
    SetNextBootHostStartupOptions(HostStartupOptions),
    SpdDataUpdate { index: u8, offset: usize, len: u8 },
}

impl From<TraceSet<MacAddressBlock>> for Trace {
    fn from(value: TraceSet<MacAddressBlock>) -> Self {
        Self::MacAddressBlockSet(value)
    }
}

impl From<TraceSet<VpdIdentity>> for Trace {
    fn from(value: TraceSet<VpdIdentity>) -> Self {
        Self::VpdIdentitySet(value)
    }
}

#[derive(Copy, Clone, Debug, PartialEq, Eq)]
enum TraceSet<T> {
    // Initial set (always succeeds)
    Set(T),
    // Repeated set, but the same value as we have cached
    SetToSameValue(T),
    // Repeated set, but the value was different (returns an error to the
    // caller)
    AttemptedSetToNewValue(T),
}

/// Separate ring buffer for ereport events, as we probably don't care that much
/// about the sequence of ereport events relative to other packrat API events.
#[derive(Copy, Clone, PartialEq, Eq, counters::Count)]
enum EreportTrace {
    #[count(skip)]
    None,
    EreportDelivered {
        src: TaskId,
        len: u32,
    },
}

ringbuf!(Trace, 16, Trace::None);
counted_ringbuf!(EREPORT_RINGBUF, EreportTrace, 16, EreportTrace::None);

/// Number of bytes of RAM dedicated to ereport buffer storage. Each individual
/// report consumes a small amount of this (currently 12 bytes).
const EREPORT_BUFFER_SIZE: usize = 4096;

userlib::task_slot!(RNG, rng_driver);

#[export_name = "main"]
fn main() -> ! {
    struct StaticBufs {
        mac_address_block: Option<MacAddressBlock>,
        identity: Option<VpdIdentity>,
        #[cfg(feature = "gimlet")]
        gimlet_bufs: gimlet::StaticBufs,
        #[cfg(feature = "cosmo")]
        cosmo_bufs: cosmo::StaticBufs,
        ereport_storage: snitch_core::Store<EREPORT_BUFFER_SIZE>,
        ereport_recv: [u8; 1024],
    }
    let StaticBufs {
        ref mut mac_address_block,
        ref mut identity,
        #[cfg(feature = "gimlet")]
        ref mut gimlet_bufs,
        #[cfg(feature = "cosmo")]
        ref mut cosmo_bufs,
        ref mut ereport_storage,
        ref mut ereport_recv,
    } = {
        static BUFS: ClaimOnceCell<StaticBufs> =
            ClaimOnceCell::new(StaticBufs {
                mac_address_block: None,
                identity: None,
                #[cfg(feature = "gimlet")]
                gimlet_bufs: gimlet::StaticBufs::new(),
                #[cfg(feature = "cosmo")]
                cosmo_bufs: cosmo::StaticBufs::new(),
                ereport_storage: snitch_core::Store::DEFAULT,
                ereport_recv: [0; 1024],
            });
        BUFS.claim()
    };

    ereport_storage.initialize(0, 0); // TODO tid timestamp

    let mut server = ServerImpl {
        mac_address_block,
        identity,
        ereport_storage,
        ereport_recv,
        restart_id: get_restart_id(),
        next_ena: 1,
        #[cfg(feature = "gimlet")]
        gimlet_data: gimlet::GimletData::new(gimlet_bufs),
        #[cfg(feature = "grapefruit")]
        grapefruit_data: grapefruit::GrapefruitData::new(),
        #[cfg(feature = "cosmo")]
        cosmo_data: cosmo::CosmoData::new(cosmo_bufs),
    };

    let mut buffer = [0; idl::INCOMING_SIZE];
    loop {
        idol_runtime::dispatch(&mut buffer, &mut server);
    }
}

// This is a function so that the 16-byte buffer we provide to the RNG IPC
// doesn't stay on the stack forever (as it might if we did this in `main`?).
fn get_restart_id() -> ereport_messages::RestartId {
    let rng = drv_rng_api::Rng::from(RNG.get_task_id());
    let mut buf = [0u8; 16];
    // XXX(eliza): if this fails we are TURBO SCREWED...
    rng.fill(&mut buf).unwrap_lite();
    u128::from_le_bytes(buf).into()
}

struct ServerImpl {
    mac_address_block: &'static mut Option<MacAddressBlock>,
    identity: &'static mut Option<VpdIdentity>,
    ereport_storage: &'static mut snitch_core::Store<EREPORT_BUFFER_SIZE>,
    ereport_recv: &'static mut [u8; 1024],
    restart_id: gateway_ereport_messages::RestartId,
    next_ena: u64,
    #[cfg(feature = "gimlet")]
    gimlet_data: gimlet::GimletData,
    #[cfg(feature = "grapefruit")]
    grapefruit_data: grapefruit::GrapefruitData,
    #[cfg(feature = "cosmo")]
    cosmo_data: cosmo::CosmoData,
}

impl ServerImpl {
    // Implementation for properties that may only be set once (e.g., our MAC
    // address block). If `storage` is already `Some(_)`, we log the extra set
    // and return an error if `value` doesn't match.
    fn set_once<T>(
        storage: &mut Option<T>,
        value: T,
    ) -> Result<(), CacheSetError>
    where
        Trace: From<TraceSet<T>>,
        T: PartialEq + Copy,
    {
        match storage {
            Some(prev) => {
                if *prev == value {
                    ringbuf_entry!(TraceSet::SetToSameValue(value).into());

                    // TODO Is this the right return value? Does a caller care
                    // if their set was actually ignored because we already had
                    // the value cached?
                    Ok(())
                } else {
                    ringbuf_entry!(
                        TraceSet::AttemptedSetToNewValue(value).into()
                    );
                    Err(CacheSetError::ValueAlreadySet)
                }
            }
            None => {
                ringbuf_entry!(TraceSet::Set(value).into());
                *storage = Some(value);
                Ok(())
            }
        }
    }
}

#[cfg(feature = "gimlet")]
impl ServerImpl {
    fn spd(&self) -> Option<&SpdData> {
        Some(self.gimlet_data.spd())
    }

    fn spd_mut(&mut self) -> Option<&mut SpdData> {
        Some(self.gimlet_data.spd_mut())
    }
}

#[cfg(feature = "cosmo")]
impl ServerImpl {
    fn spd(&self) -> Option<&SpdData> {
        Some(self.cosmo_data.spd())
    }

    fn spd_mut(&mut self) -> Option<&mut SpdData> {
        Some(self.cosmo_data.spd_mut())
    }
}

#[cfg(not(any(feature = "cosmo", feature = "gimlet")))]
impl ServerImpl {
    fn spd(&self) -> Option<&SpdData> {
        None
    }
    fn spd_mut(&mut self) -> Option<&mut SpdData> {
        None
    }
}

impl idl::InOrderPackratImpl for ServerImpl {
    fn get_mac_address_block(
        &mut self,
        _: &RecvMessage,
    ) -> Result<MacAddressBlock, RequestError<CacheGetError>> {
        let addrs = self.mac_address_block.ok_or(CacheGetError::ValueNotSet)?;
        Ok(addrs)
    }

    fn set_mac_address_block(
        &mut self,
        _: &RecvMessage,
        macs: MacAddressBlock,
    ) -> Result<(), RequestError<CacheSetError>> {
        Self::set_once(self.mac_address_block, macs).map_err(Into::into)
    }

    fn get_identity(
        &mut self,
        _: &RecvMessage,
    ) -> Result<VpdIdentity, RequestError<CacheGetError>> {
        let addrs = self.identity.ok_or(CacheGetError::ValueNotSet)?;
        Ok(addrs)
    }

    fn set_identity(
        &mut self,
        _: &RecvMessage,
        identity: VpdIdentity,
    ) -> Result<(), RequestError<CacheSetError>> {
        Self::set_once(self.identity, identity).map_err(Into::into)
    }

    #[cfg(feature = "gimlet")]
    fn get_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
    ) -> Result<HostStartupOptions, RequestError<Infallible>> {
        Ok(self.gimlet_data.host_startup_options())
    }

    #[cfg(feature = "grapefruit")]
    fn get_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
    ) -> Result<HostStartupOptions, RequestError<Infallible>> {
        Ok(self.grapefruit_data.host_startup_options())
    }

    #[cfg(feature = "cosmo")]
    fn get_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
    ) -> Result<HostStartupOptions, RequestError<Infallible>> {
        Ok(self.cosmo_data.host_startup_options())
    }

    #[cfg(not(any(
        feature = "gimlet",
        feature = "grapefruit",
        feature = "cosmo"
    )))]
    fn get_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
    ) -> Result<HostStartupOptions, RequestError<Infallible>> {
        Err(RequestError::Fail(
            idol_runtime::ClientError::BadMessageContents,
        ))
    }

    #[cfg(feature = "gimlet")]
    fn set_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
        host_startup_options: HostStartupOptions,
    ) -> Result<(), RequestError<Infallible>> {
        ringbuf_entry!(Trace::SetNextBootHostStartupOptions(
            host_startup_options
        ));
        self.gimlet_data
            .set_host_startup_options(host_startup_options);
        Ok(())
    }

    #[cfg(feature = "grapefruit")]
    fn set_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
        host_startup_options: HostStartupOptions,
    ) -> Result<(), RequestError<Infallible>> {
        ringbuf_entry!(Trace::SetNextBootHostStartupOptions(
            host_startup_options
        ));
        self.grapefruit_data
            .set_host_startup_options(host_startup_options);
        Ok(())
    }

    #[cfg(feature = "cosmo")]
    fn set_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
        host_startup_options: HostStartupOptions,
    ) -> Result<(), RequestError<Infallible>> {
        ringbuf_entry!(Trace::SetNextBootHostStartupOptions(
            host_startup_options
        ));
        self.cosmo_data
            .set_host_startup_options(host_startup_options);
        Ok(())
    }

    #[cfg(not(any(
        feature = "gimlet",
        feature = "cosmo",
        feature = "grapefruit"
    )))]
    fn set_next_boot_host_startup_options(
        &mut self,
        _: &RecvMessage,
        _host_startup_options: HostStartupOptions,
    ) -> Result<(), RequestError<Infallible>> {
        Err(RequestError::Fail(
            idol_runtime::ClientError::BadMessageContents,
        ))
    }

    fn set_spd_eeprom(
        &mut self,
        _: &RecvMessage,
        index: u8,
        offset: usize,
        data: LenLimit<Leased<idol_runtime::R, [u8]>, 256>,
    ) -> Result<(), RequestError<Infallible>> {
        if let Some(spd) = self.spd_mut() {
            spd.set_eeprom(index, offset, data)
        } else {
            Err(RequestError::Fail(
                idol_runtime::ClientError::BadMessageContents,
            ))
        }
    }

    fn get_spd_present(
        &mut self,
        _: &RecvMessage,
        index: u8,
    ) -> Result<bool, RequestError<Infallible>> {
        if let Some(spd) = self.spd() {
            spd.get_present(index)
        } else {
            Err(RequestError::Fail(
                idol_runtime::ClientError::BadMessageContents,
            ))
        }
    }

    fn get_spd_data(
        &mut self,
        _: &RecvMessage,
        index: u8,
        offset: usize,
    ) -> Result<u8, RequestError<Infallible>> {
        if let Some(spd) = self.spd() {
            spd.get_data(index, offset)
        } else {
            Err(RequestError::Fail(
                idol_runtime::ClientError::BadMessageContents,
            ))
        }
    }

    fn get_full_spd_data(
        &mut self,
        _: &RecvMessage,
        index: u8,
        out: Leased<idol_runtime::W, [u8]>,
    ) -> Result<(), RequestError<Infallible>> {
        if let Some(spd) = self.spd() {
            spd.get_full_data(index, out)
        } else {
            Err(RequestError::Fail(
                idol_runtime::ClientError::BadMessageContents,
            ))
        }
    }

    fn deliver_ereport(
        &mut self,
        msg: &RecvMessage,
        data: LenLimit<Leased<idol_runtime::R, [u8]>, 1024usize>,
    ) -> Result<(), RequestError<Infallible>> {
        data.read_range(0..data.len(), self.ereport_recv)
            .map_err(|_| ClientError::WentAway.fail())?;
        self.ereport_storage.insert(
            msg.sender.0,
            0,
            &self.ereport_recv[..data.len()],
        );
        // TODO(eliza): would maybe be nice to say something if the ereport got
        // eaten...
        ringbuf_entry!(
            EREPORT_RINGBUF,
            EreportTrace::EreportDelivered {
                src: msg.sender,
                len: data.len() as u32
            }
        );
        Ok(())
    }

    fn read_ereports(
        &mut self,
        _msg: &RecvMessage,
        request_id: ereport_messages::RequestIdV0,
        restart_id: ereport_messages::RestartId,
        begin_ena: ereport_messages::Ena,
        data: Leased<idol_runtime::W, [u8]>,
    ) -> Result<usize, RequestError<Infallible>> {
        // Skip over a header-sized initial chunk.
        let first_data_byte = size_of::<ereport_messages::ResponseHeader>();

        let mut position = first_data_byte;
        let mut first_written_ena = None;

        // If the requested restart ID matches the current restart ID, then read
        // from the requested ENA. If not, start at ENA 0.
        let begin_ena = if restart_id == self.restart_id {
            begin_ena.into()
        } else {
            // TODO(eliza): encode metadata if restart ID doesn't match!
            0
        };

        // Beginning with the first
        for r in self.ereport_storage.read_from(begin_ena.into()) {
            if first_written_ena.is_none() {
                first_written_ena = Some(r.ena);
                // Start CBOR list
                // XXX(eliza): in theory it might be nicer to use
                // `minicbor::data::Token::BeginArray` here, but it's way more
                // annoying in practice...
                data.write_at(position, 0x9f)
                    .map_err(|_| ClientError::WentAway.fail())?;
                position += 1;
            }

            let tid = TaskId(r.tid);
            let task_name = hubris_task_names::TASK_NAMES
                .get(tid.index())
                .copied()
                .unwrap_or({
                    // This represents an internal error, where we've recorded
                    // an out-of-range task ID somehow. We still want to get the
                    // ereport out, so we'll use a recognizable but illegal task
                    // name to indicate that it's missing.
                    "-" // TODO
                });
            // TODO write task name
            let generation = tid.generation();
            // TODO write generation number
            r.timestamp; // TODO

            let entry = (
                task_name,
                u8::from(generation),
                r.timestamp,
                ByteGather(r.slices.0, r.slices.1),
            );
            let mut c = minicbor::encode::write::Cursor::new(
                &mut self.ereport_recv[..],
            );
            match minicbor::encode(&entry, &mut c) {
                Ok(()) => {
                    let size = c.position();
                    data.write_range(
                        position..position + size,
                        &self.ereport_recv[..size],
                    )
                    .map_err(|_| ClientError::WentAway.fail())?;
                    position += size;
                }
                Err(_end) => {
                    // This is an odd one; we've admitted a record into our
                    // queue that won't fit in our buffer. This can happen
                    // because of the encoding overhead, in theory, but should
                    // be prevented.
                    // TODO
                }
            }
        }

        if first_written_ena.is_some() {
            // End CBOR list, if we wrote anything.
            data.write_at(position, 0xff)
                .map_err(|_| ClientError::WentAway.fail())?;
            position += 1;
        }

        let first_ena = first_written_ena.unwrap_or(self.next_ena);
        let header = ereport_messages::ResponseHeader::V0(
            ereport_messages::ResponseHeaderV0 {
                request_id,
                restart_id: self.restart_id,
                start_ena: first_ena.into(),
            },
        );
        data.write_range(0..size_of_val(&header), header.as_bytes())
            .map_err(|_| ClientError::WentAway.fail())?;
        Ok(position)
    }

    fn flush_ereports(
        &mut self,
        _msg: &RecvMessage,
        last_ena: u64,
    ) -> Result<(), RequestError<Infallible>> {
        self.ereport_storage.flush_thru(last_ena);
        Ok(())
    }
}

impl NotificationHandler for ServerImpl {
    fn current_notification_mask(&self) -> u32 {
        // We don't use notifications, don't listen for any.
        0
    }

    fn handle_notification(&mut self, _bits: u32) {
        unreachable!()
    }
}

struct ByteGather<'a, 'b>(&'a [u8], &'b [u8]);

impl<C> minicbor::Encode<C> for ByteGather<'_, '_> {
    fn encode<W: minicbor::encode::Write>(
        &self,
        e: &mut minicbor::Encoder<W>,
        _ctx: &mut C,
    ) -> Result<(), minicbor::encode::Error<W::Error>> {
        e.bytes_len((self.0.len() + self.1.len()) as u64)?;
        e.writer_mut()
            .write_all(self.0)
            .map_err(minicbor::encode::Error::write)?;
        e.writer_mut()
            .write_all(self.1)
            .map_err(minicbor::encode::Error::write)?;
        Ok(())
    }
}

impl<C> CborLen<C> for ByteGather<'_, '_> {
    fn cbor_len(&self, ctx: &mut C) -> usize {
        let n = self.0.len() + self.1.len();
        n.cbor_len(ctx) + n
    }
}

mod idl {
    use super::{
        ereport_messages, CacheGetError, CacheSetError, HostStartupOptions,
        MacAddressBlock, VpdIdentity,
    };

    include!(concat!(env!("OUT_DIR"), "/server_stub.rs"));
}
